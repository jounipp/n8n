{
  "nodes": [
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO outlook.email_interest\n  (message_id, model_name, model_version, interest_label, primary_category, interest_sublabel,\n   confidence, priority_score, reasons, rule_conditions, recommended_action,\n   due_at, status, decided_at, requires_deep_analysis)\nSELECT \n  $1, \n  $2, \n  $3, \n  $4, \n  $5, \n  $6,\n  CASE WHEN $7 IS NULL THEN NULL ELSE LEAST(GREATEST($7,0),100) END,\n  CASE WHEN $8 IS NULL THEN NULL ELSE LEAST(GREATEST($8,0),100) END,\n  CASE WHEN $9 IS NULL THEN NULL\n       WHEN $9::text='[]'      THEN ARRAY[]::text[]\n       WHEN jsonb_typeof($9::jsonb)='array' THEN ARRAY(SELECT jsonb_array_elements_text($9::jsonb))\n       ELSE ARRAY[ trim(both '\"' from ($9::jsonb)::text) ] END,\n  $10,\n  $11,\n  NULLIF($12,'')::timestamptz,\n  $13,\n  $14::timestamptz,\n  COALESCE($15, false)\nWHERE EXISTS (\n  SELECT 1 FROM outlook.emails_ingest\n  WHERE message_id = $1\n  AND is_deleted = FALSE\n)\nON CONFLICT (message_id, model_name, model_version) DO UPDATE SET\n  interest_label     = EXCLUDED.interest_label,\n  primary_category   = EXCLUDED.primary_category,\n  interest_sublabel  = EXCLUDED.interest_sublabel,\n  confidence         = EXCLUDED.confidence,\n  priority_score     = EXCLUDED.priority_score,\n  reasons            = EXCLUDED.reasons,\n  rule_conditions    = EXCLUDED.rule_conditions,\n  recommended_action = EXCLUDED.recommended_action,\n  due_at             = EXCLUDED.due_at,\n  status             = EXCLUDED.status,\n  decided_at         = EXCLUDED.decided_at,\n  requires_deep_analysis = EXCLUDED.requires_deep_analysis\nWHERE\n  (email_interest.decided_at IS NULL OR EXCLUDED.decided_at > email_interest.decided_at)\n  AND (email_interest.confidence IS NULL OR EXCLUDED.confidence >= email_interest.confidence)\nRETURNING message_id;",
        "options": {
          "queryReplacement": "={{[\n  $json.ei.message_id,\n  $json.ei.model_name,\n  $json.ei.model_version,\n  $json.ei.interest_label,\n  $json.ei.primary_category,\n  $json.ei.interest_sublabel,\n  $json.ei.confidence,\n  $json.ei.priority_score,\n  JSON.stringify($json.ei.reasons ?? []),\n  $json.ei.rule_conditions,\n  $json.ei.recommended_action,\n  $json.ei.due_at_utc,\n  $json.ei.status,\n  $json.ei.decided_at_utc,\n  $json.ei.requires_deep_analysis\n]}}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        -48,
        -944
      ],
      "id": "542b6918-011e-4d64-9e25-027d030e4582",
      "name": "upsert_email_interest",
      "notesInFlow": true,
      "credentials": {
        "postgres": {
          "id": "4rl59kH75QNg0oSk",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE outlook.emails_ingest\nSET analyzed_at = NOW()\nWHERE message_id = $1;\n",
        "options": {
          "queryReplacement": "={{ [ $json.message_id ] }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        112,
        -944
      ],
      "id": "5934bf3a-64c2-4d21-aa25-17f7dfab5eee",
      "name": "mark_analyzed",
      "notesInFlow": true,
      "credentials": {
        "postgres": {
          "id": "4rl59kH75QNg0oSk",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Normalisoi recommended_action vakiojoukkoon.\n// Palauttaa 1→1: { ...ei.recommended_action = one of:\n// 'none','read','review','follow_up','urgent','archive','calendar_consider' }\n\nconst MAP = [\n  { keys: ['archive_after_review','archive'],                    out: 'archive' },\n  { keys: ['review_and_decide','review_when_convenient','read_when_convenient','review_later','optional_review','review'], out: 'review' },\n  { keys: ['follow_up_in_days','follow_up'],                     out: 'follow_up' },\n  { keys: ['calendar_consider','consider_attendance'],           out: 'calendar_consider' },\n  { keys: ['urgent','respond_now'],                              out: 'urgent' },\n  { keys: ['read'],                                              out: 'read' },\n];\n\nfunction norm(x){ return (x ?? '').toString().trim().toLowerCase(); }\nfunction mapAction(a){\n  const s = norm(a);\n  for (const m of MAP) if (m.keys.some(k => s.includes(k))) return m.out;\n  return s || 'none';\n}\n\nreturn items.map(({ json }) => {\n  if (!json?.ei?.message_id) throw new Error('normalize_ei: ei.message_id puuttuu');\n  const ei = { ...json.ei };\n  ei.recommended_action = mapAction(ei.recommended_action);\n  // turvat: rajaa pisteet 0..100 jos tulevat yli/ali\n  if (Number.isFinite(+ei.confidence))      ei.confidence      = Math.min(100, Math.max(0, +ei.confidence));\n  if (Number.isFinite(+ei.priority_score))  ei.priority_score  = Math.min(100, Math.max(0, +ei.priority_score));\n  return { json: { ...json, ei } };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -240,
        -976
      ],
      "id": "2f76aa21-2001-4665-ac09-e4f3c8a0e0ca",
      "name": "normalize_ei"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO outlook.content_analysis (\n  message_id, language, word_count, sentence_count,\n  topics, ai_tags, persons_mentioned, organizations_mentioned, \n  locations_mentioned, categories_found, external_links, article_links,\n  ai_summary, sentiment_score, business_relevance_score,\n  content_structure, analyzer_version, analyzed_at, analysis_level\n)\nSELECT \n  $1, $2, $3, $4,\n  \n  /* topics */\n  CASE WHEN $5 IS NULL THEN NULL\n       WHEN $5::text='[]'       THEN ARRAY[]::text[]\n       WHEN jsonb_typeof($5::jsonb)='array' THEN ARRAY(SELECT jsonb_array_elements_text($5::jsonb))\n       ELSE ARRAY[ trim(both '\"' from ($5::jsonb)::text) ] END,\n\n  /* ai_tags */\n  CASE WHEN $6 IS NULL THEN NULL\n       WHEN $6::text='[]'       THEN ARRAY[]::text[]\n       WHEN jsonb_typeof($6::jsonb)='array' THEN ARRAY(SELECT jsonb_array_elements_text($6::jsonb))\n       ELSE ARRAY[ trim(both '\"' from ($6::jsonb)::text) ] END,\n\n  /* persons_mentioned */\n  CASE WHEN $7 IS NULL THEN NULL\n       WHEN $7::text='[]'       THEN ARRAY[]::text[]\n       WHEN jsonb_typeof($7::jsonb)='array' THEN ARRAY(SELECT jsonb_array_elements_text($7::jsonb))\n       ELSE ARRAY[ trim(both '\"' from ($7::jsonb)::text) ] END,\n\n  /* organizations_mentioned */\n  CASE WHEN $8 IS NULL THEN NULL\n       WHEN $8::text='[]'       THEN ARRAY[]::text[]\n       WHEN jsonb_typeof($8::jsonb)='array' THEN ARRAY(SELECT jsonb_array_elements_text($8::jsonb))\n       ELSE ARRAY[ trim(both '\"' from ($8::jsonb)::text) ] END,\n\n  /* locations_mentioned */\n  CASE WHEN $9 IS NULL THEN NULL\n       WHEN $9::text='[]'       THEN ARRAY[]::text[]\n       WHEN jsonb_typeof($9::jsonb)='array' THEN ARRAY(SELECT jsonb_array_elements_text($9::jsonb))\n       ELSE ARRAY[ trim(both '\"' from ($9::jsonb)::text) ] END,\n\n  /* categories_found */\n  CASE WHEN $10 IS NULL THEN NULL\n       WHEN $10::text='[]'      THEN ARRAY[]::text[]\n       WHEN jsonb_typeof($10::jsonb)='array' THEN ARRAY(SELECT jsonb_array_elements_text($10::jsonb))\n       ELSE ARRAY[ trim(both '\"' from ($10::jsonb)::text) ] END,\n\n  /* external_links */\n  CASE WHEN $11 IS NULL THEN NULL\n       WHEN $11::text='[]'      THEN ARRAY[]::text[]\n       WHEN jsonb_typeof($11::jsonb)='array' THEN ARRAY(SELECT jsonb_array_elements_text($11::jsonb))\n       ELSE ARRAY[ trim(both '\"' from ($11::jsonb)::text) ] END,\n\n  /* article_links */\n  CASE WHEN $12 IS NULL THEN NULL\n       WHEN $12::text='[]'      THEN ARRAY[]::text[]\n       WHEN jsonb_typeof($12::jsonb)='array' THEN ARRAY(SELECT jsonb_array_elements_text($12::jsonb))\n       ELSE ARRAY[ trim(both '\"' from ($12::jsonb)::text) ] END,\n\n  $13,\n\n  /* sentiment −1..1 */\n  CASE WHEN $14 IS NULL THEN NULL ELSE GREATEST(LEAST($14, 1.0), -1.0) END,\n\n  /* relevance 0..100 → 0..9.99 (numeric(3,2)) */\n  CASE WHEN $15 IS NULL THEN NULL ELSE LEAST(GREATEST($15, 0), 100) / 100.0 END,\n\n  /* content_structure */\n  $16::jsonb,\n\n  $17, $18::timestamptz, $19\n\nWHERE EXISTS (\n  SELECT 1 FROM outlook.emails_ingest \n  WHERE message_id = $1 \n  AND is_deleted = FALSE\n)\n\nON CONFLICT (message_id) DO UPDATE SET\n  language                 = EXCLUDED.language,\n  word_count               = EXCLUDED.word_count,\n  sentence_count           = EXCLUDED.sentence_count,\n  topics                   = EXCLUDED.topics,\n  ai_tags                  = EXCLUDED.ai_tags,\n  persons_mentioned        = EXCLUDED.persons_mentioned,\n  organizations_mentioned  = EXCLUDED.organizations_mentioned,\n  locations_mentioned      = EXCLUDED.locations_mentioned,\n  categories_found         = EXCLUDED.categories_found,\n  external_links           = EXCLUDED.external_links,\n  article_links            = EXCLUDED.article_links,\n  ai_summary               = EXCLUDED.ai_summary,\n  sentiment_score          = EXCLUDED.sentiment_score,\n  business_relevance_score = EXCLUDED.business_relevance_score,\n  content_structure        = EXCLUDED.content_structure,\n  analyzer_version         = EXCLUDED.analyzer_version,\n  analyzed_at              = EXCLUDED.analyzed_at,\n  analysis_level           = EXCLUDED.analysis_level\nWHERE\n  (content_analysis.analysis_level IS DISTINCT FROM 'deep' OR EXCLUDED.analysis_level = 'deep')\n  AND (content_analysis.analyzed_at IS NULL OR EXCLUDED.analyzed_at > content_analysis.analyzed_at);",
        "options": {
          "queryReplacement": "={{[\n  $json.ca.message_id,\n  $json.ca.language,\n  $json.ca.word_count,\n  $json.ca.sentence_count,\n  JSON.stringify($json.ca.topics ?? null),\n  JSON.stringify($json.ca.ai_tags ?? null),\n  JSON.stringify($json.ca.persons_mentioned ?? null),\n  JSON.stringify($json.ca.organizations_mentioned ?? null),\n  JSON.stringify($json.ca.locations_mentioned ?? null),\n  JSON.stringify($json.ca.categories_found ?? null),\n  JSON.stringify($json.ca.external_links ?? null),\n  JSON.stringify($json.ca.article_links ?? null),\n  $json.ca.ai_summary,\n  $json.ca.sentiment_score,\n  $json.ca.business_relevance_score,\n  JSON.stringify($json.ca.content_structure ?? null),\n  $json.ca.analyzer_version,\n  $json.ca.analyzed_at_utc,\n  $json.ca.analysis_level\n]}}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        -64,
        -1296
      ],
      "id": "5c3ac588-5c1d-4414-acce-0f95092778d1",
      "name": "upsert_content_analysis",
      "notesInFlow": true,
      "credentials": {
        "postgres": {
          "id": "4rl59kH75QNg0oSk",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH ins AS (\n  INSERT INTO outlook.ai_analysis_log\n    (message_id, analyzer_version, analyzed_at, model_name, model_version, raw_analysis)\n  SELECT\n    $1, $2, $3::timestamptz, $4, $5, $6::jsonb\n  WHERE EXISTS (\n    SELECT 1 FROM outlook.emails_ingest e WHERE e.message_id = $1\n  )\n  RETURNING 1\n)\nSELECT COALESCE((SELECT 1 FROM ins), 0) AS inserted;\n",
        "options": {
          "queryReplacement": "={{[\n  $json.log.message_id,\n  $json.log.analyzer_version,\n  $json.log.analyzed_at,\n  $json.log.model_name,\n  $json.log.model_version,\n  $json.log.raw_analysis\n]}}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        -48,
        -1120
      ],
      "id": "ade42ac7-a74f-44cd-aac1-e9c1034631a8",
      "name": "insert_ai_analysis_log",
      "notesInFlow": true,
      "credentials": {
        "postgres": {
          "id": "4rl59kH75QNg0oSk",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE outlook.emails_ingest\nSET\n  auto_processed = false,\n  updated_at = NOW(),\n  notes = CASE\n            WHEN notes IS NULL OR notes = '' THEN CONCAT('validate_error: ', NOW()::text, ' | ', $2)\n            ELSE CONCAT(notes, ' | validate_error: ', NOW()::text, ' | ', $2)\n          END\nWHERE message_id = $1;\n",
        "options": {
          "queryReplacement": "={{ [ $json.message_id, $json.err ] }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        -512,
        -992
      ],
      "id": "7d5987c7-44ba-41b6-b9bc-42c472fcc269",
      "name": "mark_error",
      "notesInFlow": true,
      "credentials": {
        "postgres": {
          "id": "4rl59kH75QNg0oSk",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Yhtenäistää virhekirjauksen parametrit mark_errorille.\n// Hakee message_id:n eri haaroista ja tiivistää virheviestin.\n\nfunction pickMessageId(j){\n  return j?.ca?.message_id\n      || j?.ei?.message_id\n      || j?.message_id\n      || j?.id_for_join\n      || j?.graph_id\n      || j?.internet_message_id\n      || null;\n}\n\nreturn items.map((item) => {\n  const j = item.json || {};\n  const mid = pickMessageId(j);\n  if (!mid) throw new Error('prepare_error_params: message_id puuttuu virhehaarassa');\n\n  // n8n error-branch: $json ja $error ovat käytettävissä\n  const emsg = (item?.error?.message || item?.json?.error || 'unknown_error').toString();\n  const eshort = emsg.length > 500 ? emsg.slice(0, 500) : emsg;\n\n  return { json: { message_id: mid, err: eshort } };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -720,
        -1024
      ],
      "id": "dd9d16f9-f6cc-4167-bd6b-ae0870798601",
      "name": "prepare_error_params"
    },
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "id": "6e8c16f2-096c-4bdc-ae88-b014cd0834ae",
      "typeVersion": 1.1,
      "name": "Start",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "position": [
        -1472,
        -1872
      ]
    },
    {
      "parameters": {
        "jsCode": "// build_batch_prompt_cache — HYBRID VERSION\n\nfunction sanitizeText(s) {\n  if (s == null) return '';\n  let t = String(s);\n  t = t.replace(/\\uFEFF/g, '');\n  t = t.replace(/[\\u0000-\\u0008\\u000B\\u000C\\u000E-\\u001F]/g, '');\n  return t.trim();\n}\n\nfunction pickMinimalInputFields(x) {\n  return {\n    message_id: x.message_id,\n    subject: sanitizeText(x.subject),\n    from: x.from_address || x.from_domain || '',\n    text: sanitizeText(x.body_text || '')\n  };\n}\n\n// Hae data edellisestä nodesta (merge_rules_to_batch)\nconst inputData = items[0].json;\n\n// Debug\nconsole.log('Input keys:', Object.keys(inputData));\nconsole.log('batch_items exists?', !!inputData.batch_items);\n\n// Poimi kentät\nconst batchItems = inputData.batch_items || [];\nconst batchSize = inputData.batch_size || batchItems.length;\nconst batchNumber = inputData.batch_number || 1;\nconst rulesVersion = inputData.rules_version || 'default_v1';\nconst rulesDsl = inputData.rules_dsl || '';\nconst rulesCount = inputData.rules_count || 0;\n\nif (batchItems.length === 0) {\n  console.error('ERROR: No batch_items to process!');\n  return [{ json: { error: 'No batch_items' } }];\n}\n\nconst message_count = batchItems.length;\nconst inputItems = batchItems.map(pickMinimalInputFields);\nconst batch_prompt = JSON.stringify(inputItems, null, 2);\n\n// ========== SYSTEM PROMPT WITH RULES ==========\nlet system_prompt_base = `Olet rahoituskäyttöön koulutettu sähköpostiluokittelun asiantuntija.\n\nRULES VERSION: ${rulesVersion}\nRULES COUNT: ${rulesCount}`;\n\nlet rules_section = '';\nif (rulesCount > 0 && rulesDsl) {\n  rules_section = `\n\n═══════════════════════════════════════════════\nTUNNETUT LÄHETTÄJÄT JA SÄÄNNÖT (${rulesVersion})\n═══════════════════════════════════════════════\n\nKäytä näitä tunnettuja sääntöjä apuna luokittelussa:\n\n${rulesDsl}\n\nHUOM: Nämä säännöt perustuvat ${rulesCount} tunnettuun lähettäjään.\n═══════════════════════════════════════════════\n`;\n}\n\nconst system_prompt_categories = `\n\nPRIMARY_CATEGORY LUOKITTELU (PAKOLLINEN):\n\n1. business_critical\n2. personal_communication\n3. financial_news\n4. marketing\n5. notifications\n6. industry_news\n7. internal\n8. regulatory\n9. spam_low_value\n10. uncategorized\n\n[... lisää kategoriamäärittelyt tähän ...]`;\n\nconst system_prompt = system_prompt_base + rules_section + system_prompt_categories;\n\nconst user_prompt = `Analysoi seuraavat ${message_count} sähköpostia ja palauta JSON-taulukko:\\n\\n${batch_prompt}`;\n\n// Cache-muodossa\nconst system = [\n  {\n    type: \"text\",\n    text: system_prompt,\n    cache_control: { type: \"ephemeral\" }\n  }\n];\n\nconst messages = [\n  {\n    role: 'user',\n    content: user_prompt\n  }\n];\n\nreturn [{\n  json: {\n    batch_items: batchItems,\n    batch_size: batchSize,\n    batch_number: batchNumber,\n    message_count,\n    system,\n    messages,\n    rules_version: rulesVersion,\n    rules_count: rulesCount,\n    system_prompt,  // Debug\n    user_prompt,    // Debug\n    batch_prompt\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -176,
        -1584
      ],
      "id": "975d2550-bcae-4cfa-87d0-1e7a62ccf942",
      "name": "build_batch_prompt_cache"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.anthropic.com/v1/messages",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "anthropicApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "anthropic-version",
              "value": "2023-06-01"
            },
            {
              "name": "anthropic-beta",
              "value": "prompt-caching-2024-07-31"
            },
            {
              "name": "content-type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ {\n     \"model\": \"claude-sonnet-4-5-20250929\",\n     \"max_tokens\": 30000,\n     \"system\": $json.system,\n     \"messages\": $json.messages\n   } }}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -848,
        -1360
      ],
      "id": "b482eb90-7baa-408e-9e01-3e086a564168",
      "name": "ai_classify_emails_cache",
      "notesInFlow": true,
      "credentials": {
        "anthropicApi": {
          "id": "XlrgzrywMY0KCmRC",
          "name": "Anthropic account"
        }
      },
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// Loop over input items and add a new field called 'myNewField' to the JSON of each one\nfor (const item of $input.all()) {\n  item.json.myNewField = 1;\n}\n\nreturn $input.all();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -688,
        -1376
      ],
      "id": "d64eb73c-1c40-4874-9b64-13af8daeba56",
      "name": "parse_ai_response",
      "notesInFlow": true,
      "notes": "CACHE vain"
    },
    {
      "parameters": {
        "jsCode": "// Loop over input items and add a new field called 'myNewField' to the JSON of each one\nfor (const item of $input.all()) {\n  item.json.myNewField = 1;\n}\n\nreturn $input.all();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -720,
        -1184
      ],
      "id": "996db585-8f4d-46cb-aaf6-504d83242560",
      "name": "parse_ai_response1",
      "notesInFlow": true,
      "notes": "CACHE vain"
    },
    {
      "parameters": {
        "jsCode": "// parse_ai_json — n8n Code (JavaScript)\n// Parses AI response with robust error handling\n\n// ========== HELPER FUNCTIONS ==========\n\nfunction cleanInput(text) {\n  return text\n    .replace(/^\\uFEFF/, '')\n    .replace(/[\\u200B-\\u200D\\uFEFF\\u034F\\u2060]/g, '')\n    .replace(/```json\\s*/gi, '')\n    .replace(/```\\s*/g, '')\n    .replace(/…/g, '...')\n    .trim();\n}\n\nfunction findLongestValidArray(text) {\n  const candidates = [];\n  \n  for (let start = 0; start < text.length; start++) {\n    if (text[start] !== '[') continue;\n    \n    for (let end = start + 1; end < text.length; end++) {\n      if (text[end] !== ']') continue;\n      \n      const slice = text.slice(start, end + 1);\n      try {\n        const parsed = JSON.parse(slice);\n        // KRIITTINEN: Hyväksy VAIN taulukot joissa on OBJEKTEJA\n        if (Array.isArray(parsed) && \n            parsed.length > 0 && \n            typeof parsed[0] === 'object' && \n            parsed[0] !== null &&\n            !Array.isArray(parsed[0])) {\n          candidates.push({ parsed, length: parsed.length, size: slice.length });\n        }\n      } catch {}\n    }\n  }\n  \n  if (candidates.length === 0) return null;\n  // Järjestä SIZE mukaan (pisin JSON), ei length mukaan\n  candidates.sort((a, b) => b.size - a.size);\n  return candidates[0].parsed;\n}\n\nfunction getAiText(json) {\n  if (!json) return null;\n  if (json.content && Array.isArray(json.content) && json.content[0]?.text) {\n    return json.content[0].text;\n  }\n  if (typeof json === 'string') return json;\n  if (json.text) return json.text;\n  return null;\n}\n\nfunction createErrorPlaceholder(message_id, errorMsg) {\n  return {\n    message_id: message_id || 'unknown',\n    _error: errorMsg,\n    id: 0,\n    classification: {\n      category: 'uncategorized',\n      primary_category: 'uncategorized',\n      suggested_new_category: null,\n      confidence: 0,\n      is_known_pattern: false,\n      suggested_rule: null\n    },\n    pattern_discovery: {\n      domain_pattern: null,\n      subject_pattern: null,\n      content_indicators: []\n    },\n    priority_assessment: {\n      priority: 0,\n      requires_attention: false,\n      action_needed: 'none',\n      due_at_utc: null\n    },\n    entities: {\n      companies: [],\n      metrics: [],\n      dates: []\n    },\n    recommendation: {\n      category_action: 'use_existing',\n      proposed_rule: null\n    },\n    content_analysis: {\n      language: null,\n      word_count: 0,\n      sentence_count: 0,\n      topics: [],\n      ai_summary: errorMsg,\n      ai_tags: [],\n      sentiment_score: 0,\n      business_relevance_score: 0,\n      external_links: [],\n      article_links: [],\n      categories_found: [],\n      content_structure: {\n        content_location: 'mixed',\n        has_substantial_text: false,\n        primary_content_type: 'brief_summary',\n        actionable_content: false\n      },\n      analyzer_version: 'claude-sonnet-4-5-20250929',\n      analyzed_at_utc: new Date().toISOString()\n    },\n    decision: {\n      model_name: 'claude',\n      model_version: 'claude-sonnet-4-5-20250929',\n      interest_label: 'uncategorized',\n      interest_sublabel: null,\n      confidence: 0,\n      priority_score: 0,\n      reasons: [errorMsg],\n      rule_conditions: null,\n      recommended_action: 'none',\n      due_at_utc: null,\n      status: 'proposed',\n      decided_at_utc: new Date().toISOString()\n    },\n    analysis_level: 'signal'\n  };\n}\n\n// ========== MAIN ==========\n\nconst aiOutput = $('ai_classify_emails_cache').first().json;\nconst batchData = $('build_batch_prompt_cache').first().json;  // ← KORJATTU!\nconst batchItems = batchData.batch_items || [];\nconst expected = batchData.message_count || batchData.batch_size || batchItems.length;\n\nif (batchItems.length === 0) {\n  return [{ json: createErrorPlaceholder(null, 'Ei viestejä käsiteltäväksi') }];\n}\n\nconst rawIn = getAiText(aiOutput);\n\nif (!rawIn) {\n  return batchItems.map(item => ({\n    json: createErrorPlaceholder(item.message_id, 'AI ei palauttanut tekstiä')\n  }));\n}\n\nconst cleaned = cleanInput(rawIn);\nconst arr = findLongestValidArray(cleaned);\n\nif (!arr) {\n  return batchItems.map(item => ({\n    json: createErrorPlaceholder(item.message_id, 'JSON parsinta epäonnistui')\n  }));\n}\n\nif (!Array.isArray(arr)) {\n  return batchItems.map(item => ({\n    json: createErrorPlaceholder(item.message_id, 'AI palautti ei-taulukon')\n  }));\n}\n\nif (arr.length < expected) {\n  const receivedIds = new Set(arr.map(x => x?.message_id).filter(Boolean));\n  \n  batchItems.forEach(item => {\n    if (!receivedIds.has(item.message_id)) {\n      arr.push(createErrorPlaceholder(item.message_id, 'AI ei palauttanut'));\n    }\n  });\n}\n\nreturn arr.map((obj, idx) => {\n  if (!obj || typeof obj !== 'object') {\n    const mid = batchItems[idx]?.message_id || `unknown_${idx}`;\n    return { json: createErrorPlaceholder(mid, 'AI palautti virheellisen objektin') };\n  }\n  \n  if (!obj.message_id) {\n    obj.message_id = batchItems[idx]?.message_id || `unknown_${idx}`;\n  }\n  \n  return { json: obj };\n});"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -496,
        -1200
      ],
      "id": "3c2afc7a-86ed-4a8c-9dc1-3c1460d0c899",
      "name": "parse_ai_json_cache"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO outlook.process_log (\n  workflow_name,\n  operation,\n  stage,\n  batch_size,\n  started_at,\n  completed_at,\n  detail,\n  items_processed,\n  api_calls_made,\n  created_at\n)\nVALUES (\n  'delta_validate',\n  'ai_classify',\n  'usage_tracking',\n  $1,  -- batch_size (montako viestiä)\n  $2::timestamptz,  -- timestamp\n  $2::timestamptz,\n  $3::jsonb,  -- usage metadata\n  $1,\n  1,  -- yksi AI-kutsu\n  NOW()\n);",
        "options": {
          "queryReplacement": "={{ [\n  $json._batch_size,\n  $json._usage_metadata.timestamp,\n  JSON.stringify($json._usage_metadata)\n] }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        -336,
        -1376
      ],
      "id": "e645325b-afdb-4acd-aa40-604b477f0a29",
      "name": "log_ai_usage_cache",
      "notesInFlow": true,
      "credentials": {
        "postgres": {
          "id": "4rl59kH75QNg0oSk",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// build_log_ai — KORJATTU versio\nreturn items.map(({ json }) => {\n  if (!json.message_id) {\n    throw new Error('build_log_ai: message_id puuttuu inputista');\n  }\n  \n  if (!json.content_analysis) {\n    throw new Error('build_log_ai: content_analysis puuttuu inputista');\n  }\n  \n  if (!json.decision) {\n    throw new Error('build_log_ai: decision puuttuu inputista');\n  }\n  \n  const now = new Date().toISOString();  // ← LISÄTTY: yhteinen timestamp\n  \n  // Rakenna content_analysis (ca)\n  const ca = {\n    message_id: json.message_id,\n    ...json.content_analysis,\n    analyzed_at_utc: now,  // ← LISÄTTY!\n    analysis_level: json.analysis_level || 'signal'\n  };\n  \n  // Rakenna email_interest (ei) decision-osiosta\n  const ei = {\n    message_id: json.message_id,\n    model_name: json.decision.model_name || 'claude',\n    model_version: json.decision.model_version || 'claude-sonnet-4-5-20250929',\n    interest_label: json.decision.interest_label || json.classification.primary_category,\n    primary_category: json.classification.primary_category,\n    interest_sublabel: json.decision.interest_sublabel || null,\n    confidence: json.decision.confidence || json.classification.confidence || 0,\n    priority_score: json.decision.priority_score || json.priority_assessment.priority || 0,\n    reasons: json.decision.reasons || [],\n    rule_conditions: json.decision.rule_conditions || json.classification.suggested_rule || null,\n    recommended_action: json.decision.recommended_action || json.priority_assessment.action_needed || 'none',\n    due_at_utc: json.decision.due_at_utc || json.priority_assessment.due_at_utc || null,\n    status: json.decision.status || 'proposed',\n    decided_at_utc: now,  // ← KORJATTU: käytä samaa timestampia\n    requires_deep_analysis: json.decision.requires_deep_analysis || false\n  };\n  \n  // Rakenna audit log\n  const log = {\n    message_id: json.message_id,\n    analyzer_version: ca.analyzer_version || 'claude-sonnet-4-5-20250929',\n    analyzed_at: now,  // ← KORJATTU: käytä samaa timestampia\n    model_name: ei.model_name,\n    model_version: ei.model_version,\n    raw_analysis: json\n  };\n  \n  return { json: { log, ca, ei } };\n});"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -320,
        -1200
      ],
      "id": "bf202183-223c-4f45-bc51-8f6cf0f0fcc7",
      "name": "build_log_ai_cache"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Hae voimassa oleva snapshot TAI palauta tyhjä default-rivi\nWITH s AS (\n  SELECT \n    version, \n    rules_json, \n    rules_dsl, \n    expires_at, \n    is_active, \n    rules_count, \n    created_at\n  FROM outlook.rules_snapshot\n  WHERE is_active = TRUE \n    AND expires_at > NOW()\n  ORDER BY created_at DESC\n  LIMIT 1\n)\nSELECT * FROM s\nUNION ALL\nSELECT\n  NULL::text AS version,\n  '[]'::jsonb AS rules_json,\n  ''::text AS rules_dsl,\n  NOW() AS expires_at,\n  FALSE AS is_active,\n  0 AS rules_count,\n  NOW() AS created_at\nWHERE NOT EXISTS (SELECT 1 FROM s);",
        "options": {}
      },
      "id": "fdcb1e90-c0ae-4d75-8fa7-b1ff27e19dac",
      "name": "get_rules_snapshot",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        -1296,
        -1696
      ],
      "notesInFlow": true,
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "4rl59kH75QNg0oSk",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Hae aktiiviset säännöt JA niiden uusimmat metriikat\nSELECT \n  r.id,\n  r.version,\n  r.feature,\n  r.key_value,\n  r.target_category,\n  r.priority,\n  r.recommended_action,\n  r.scope,\n  r.rule_type,\n  COALESCE(m.support, 0) AS support,\n  COALESCE(m.precision_cat_pct, 0) AS precision_cat_pct,\n  COALESCE(m.avg_relevance_pct, 0) AS avg_relevance_pct\nFROM outlook.classification_rules r\nLEFT JOIN LATERAL (\n  SELECT \n    support, \n    precision_cat_pct, \n    avg_relevance_pct\n  FROM outlook.classification_rule_metrics\n  WHERE rule_id = r.id\n  ORDER BY measured_at DESC\n  LIMIT 1\n) m ON TRUE\nWHERE r.is_active = TRUE\nORDER BY r.priority ASC, COALESCE(m.support, 0) DESC;",
        "options": {}
      },
      "id": "a31d39f4-de6b-435e-9ead-e7fe7e922c8b",
      "name": "load_classification_rules",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        -928,
        -1616
      ],
      "notesInFlow": true,
      "credentials": {
        "postgres": {
          "id": "4rl59kH75QNg0oSk",
          "name": "Postgres account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Invalidoi vanhat ja tallenna uusi snapshot\nWITH invalidated AS (\n  UPDATE outlook.rules_snapshot\n  SET is_active = FALSE\n  WHERE is_active = TRUE\n  RETURNING version AS old_version\n),\ninserted AS (\n  INSERT INTO outlook.rules_snapshot (\n    version,\n    rules_json,\n    rules_dsl,\n    expires_at,\n    rules_count,\n    total_support,\n    avg_precision,\n    is_active,\n    ttl_hours\n  )\n  VALUES (\n    '{{ $json.version }}',\n    '{{ $json.rules_json }}'::jsonb,\n    '{{ $json.rules_dsl }}',\n    '{{ $json.expires_at }}'::timestamptz,\n    {{ $json.rules_count }},\n    {{ $json.total_support }},\n    {{ $json.avg_precision }},\n    TRUE,\n    24\n  )\n  RETURNING \n    version, \n    created_at, \n    expires_at, \n    rules_count,\n    total_support,\n    avg_precision\n)\nSELECT \n  i.*,\n  (SELECT COUNT(*) FROM invalidated) AS invalidated_count\nFROM inserted i;",
        "options": {
          "queryBatching": "all"
        }
      },
      "id": "a6e0b4b4-2ba7-4c2e-aba6-2609385a5a9a",
      "name": "save_rules_snapshot",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        -592,
        -1664
      ],
      "notesInFlow": true,
      "credentials": {
        "postgres": {
          "id": "4rl59kH75QNg0oSk",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "429737d9-5fca-4a3a-be62-320a8fcf1d96",
              "leftValue": "={{ $json.version }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty",
                "singleValue": true
              }
            },
            {
              "id": "60dcba12-2005-411f-ad89-fba765c1afcf",
              "leftValue": "={{ new Date($json.expires_at).getTime() > Date.now() }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -1136,
        -1696
      ],
      "id": "bdebb1dc-3d8c-45b7-af1d-42ac7e8e5027",
      "name": "check_cache_valid"
    },
    {
      "parameters": {
        "jsCode": "// Rakentaa DSL-tekstin classification_rules riveistä\n\nconst rules = items.map(i => i.json);\n\nif (rules.length === 0) {\n  return [{\n    json: {\n      version: 'default_v1',\n      rules_json: [],\n      rules_dsl: '',\n      expires_at: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),\n      rules_count: 0,\n      total_support: 0,\n      avg_precision: 0\n    }\n  }];\n}\n\n// Järjestä prioriteetin ja tuen mukaan\nrules.sort((a, b) => {\n  if (a.priority !== b.priority) return a.priority - b.priority;\n  return (b.support || 0) - (a.support || 0);\n});\n\n// Ryhmittele kategorioittain\nconst rulesByCategory = {};\nrules.forEach(r => {\n  if (!rulesByCategory[r.target_category]) {\n    rulesByCategory[r.target_category] = [];\n  }\n  \n  const precision = r.precision_cat_pct || 0;\n  const confidence = precision >= 95 ? 'KORKEA' :\n                     precision >= 80 ? 'HYVÄ' : \n                     precision >= 60 ? 'KOHTALAINEN' : 'MATALA';\n  \n  rulesByCategory[r.target_category].push({\n    feature: r.feature,\n    value: r.key_value,\n    support: r.support || 0,\n    precision: confidence,\n    action: r.recommended_action || 'review'\n  });\n});\n\n// Luo DSL-teksti\nconst dslLines = [];\nfor (const [category, categoryRules] of Object.entries(rulesByCategory)) {\n  dslLines.push(`\\n=== ${category.toUpperCase()} ===`);\n  categoryRules.forEach(r => {\n    const supportText = r.support > 0 ? `${r.support} osumaa` : 'ei dataa';\n    dslLines.push(`- JOS ${r.feature}=\"${r.value}\" → ${category} (${r.precision} tarkkuus, ${supportText}, toimenpide: ${r.action})`);\n  });\n}\n\nconst dsl = dslLines.join('\\n');\nconst version = `hybrid_${new Date().toISOString().split('T')[0]}_r${rules.length}`;\nconst ttlHours = 24;\nconst expiresAt = new Date(Date.now() + ttlHours * 60 * 60 * 1000).toISOString();\n\nconst totalSupport = rules.reduce((sum, r) => sum + (r.support || 0), 0);\nconst avgPrecision = rules.length > 0 \n  ? rules.reduce((sum, r) => sum + (r.precision_cat_pct || 0), 0) / rules.length\n  : 0;\n\nreturn [{\n  json: {\n    version: version,\n    rules_json: rules,\n    rules_dsl: dsl,\n    expires_at: expiresAt,\n    rules_count: rules.length,\n    total_support: totalSupport,\n    avg_precision: Math.round(avgPrecision * 100) / 100\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -752,
        -1616
      ],
      "id": "6296d4c7-5a46-4490-8ecb-bc955449421a",
      "name": "build_rules_dsl"
    },
    {
      "parameters": {
        "jsCode": "// Yhdistää rules_snapshot datan batch_items dataan\n// HUOM: Tämä node tarvitsee KAKSI inputtia!\n\n// Input 0: Alkuperäinen batch data Start-nodesta\n// Input 1: Rules data (cache hit TAI cache miss)\n\nconst inputs = $input.all();\n\n// Debug: montako inputtia saadaan\nif (!inputs || inputs.length === 0) {\n  return [{\n    json: {\n      error: 'No inputs received',\n      batch_items: [],\n      rules_version: 'error_no_input'\n    }\n  }];\n}\n\n// Etsi batch data ja rules data\nlet batchData = null;\nlet rulesData = null;\n\n// Käy läpi kaikki inputit\ninputs.forEach(item => {\n  const data = item.json;\n  \n  // Jos löytyy batch_items, se on batch data\n  if (data.batch_items && Array.isArray(data.batch_items)) {\n    batchData = data;\n  }\n  \n  // Jos löytyy rules_version tai version, se on rules data  \n  if (data.rules_version || data.version) {\n    rulesData = data;\n  }\n});\n\n// Jos batch data puuttuu, yritä hakea Start nodesta\nif (!batchData) {\n  try {\n    const startNode = $('Start').first();\n    if (startNode && startNode.json) {\n      batchData = startNode.json;\n    }\n  } catch (e) {\n    // Start node ei saatavilla\n  }\n}\n\n// Fallback: jos ei batch dataa\nif (!batchData || !batchData.batch_items) {\n  batchData = {\n    batch_items: [],\n    batch_size: 0,\n    batch_number: 1\n  };\n}\n\n// Fallback: jos ei rules dataa\nif (!rulesData) {\n  rulesData = {\n    version: 'default_v1',\n    rules_json: [],\n    rules_dsl: '',\n    rules_count: 0\n  };\n}\n\n// Yhdistä data\nconst merged = {\n  // Batch kentät\n  batch_items: batchData.batch_items || [],\n  batch_size: batchData.batch_size || 0,\n  batch_number: batchData.batch_number || 1,\n  \n  // Rules kentät\n  rules_version: rulesData.version || rulesData.rules_version || 'default_v1',\n  rules_dsl: rulesData.rules_dsl || '',\n  rules_count: rulesData.rules_count || 0,\n  rules_json: rulesData.rules_json || [],\n  rules_from_cache: (rulesData.version && rulesData.version !== 'default_v1')\n};\n\nreturn [{ json: merged }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -416,
        -1872
      ],
      "id": "93b21f8a-b9df-42ea-ae8a-fea4202b7246",
      "name": "merge_rules_to_batch"
    }
  ],
  "connections": {
    "upsert_email_interest": {
      "main": [
        [
          {
            "node": "mark_analyzed",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "mark_analyzed": {
      "main": [
        []
      ]
    },
    "normalize_ei": {
      "main": [
        [
          {
            "node": "upsert_email_interest",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "insert_ai_analysis_log": {
      "main": [
        []
      ]
    },
    "prepare_error_params": {
      "main": [
        [
          {
            "node": "mark_error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Start": {
      "main": [
        [
          {
            "node": "get_rules_snapshot",
            "type": "main",
            "index": 0
          },
          {
            "node": "merge_rules_to_batch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "build_batch_prompt_cache": {
      "main": [
        [
          {
            "node": "ai_classify_emails_cache",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ai_classify_emails_cache": {
      "main": [
        [
          {
            "node": "parse_ai_response",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "parse_ai_response1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "parse_ai_response": {
      "main": [
        [
          {
            "node": "parse_ai_json_cache",
            "type": "main",
            "index": 0
          },
          {
            "node": "log_ai_usage_cache",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "parse_ai_response1": {
      "main": [
        [
          {
            "node": "prepare_error_params",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "parse_ai_json_cache": {
      "main": [
        [
          {
            "node": "build_log_ai_cache",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "build_log_ai_cache": {
      "main": [
        [
          {
            "node": "insert_ai_analysis_log",
            "type": "main",
            "index": 0
          },
          {
            "node": "upsert_content_analysis",
            "type": "main",
            "index": 0
          },
          {
            "node": "normalize_ei",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "get_rules_snapshot": {
      "main": [
        [
          {
            "node": "check_cache_valid",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "load_classification_rules": {
      "main": [
        [
          {
            "node": "build_rules_dsl",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "save_rules_snapshot": {
      "main": [
        [
          {
            "node": "merge_rules_to_batch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "check_cache_valid": {
      "main": [
        [
          {
            "node": "merge_rules_to_batch",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "load_classification_rules",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "build_rules_dsl": {
      "main": [
        [
          {
            "node": "save_rules_snapshot",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "merge_rules_to_batch": {
      "main": [
        [
          {
            "node": "build_batch_prompt_cache",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "instanceId": "5bc588890427261aec904f1de6ea2c47f92f0021d7680fbf9bd2043a6f4924b2"
  }
}