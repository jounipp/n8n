{
  "nodes": [
    {
      "parameters": {
        "jsCode": "// pre_ai_guard — n8n Code (JavaScript)\n// Tehtävä: HTML→teksti, SafeLinks-purku, whitespace-normalisointi, katkaisu, hash, token-est.\n// KORJAUS: body_content → body_text (puhdistettu versio)\n\nconst crypto = require('crypto');\n\n// --- Konfig ---\nconst cfg = ($node['set_config']?.json) || {};\nconst MAX_BODY_CHARS = Number(cfg.MAX_BODY_CHARS ?? 12000);\nconst TRIM_LINES = Number(cfg.TRIM_LEADING_TRAILING_LINES ?? 0);\n\n// --- Apurit ---\nfunction stripHtml(html) {\n  if (!html) return '';\n  let s = String(html)\n    .replace(/<script[\\s\\S]*?>[\\s\\S]*?<\\/script>/gi, '')\n    .replace(/<style[\\s\\S]*?>[\\s\\S]*?<\\/style>/gi, '')\n    .replace(/<\\/p>/gi, '\\n\\n')\n    .replace(/<br\\s*\\/?>/gi, '\\n')\n    .replace(/<\\/?[^>]+>/g, '');\n  return decodeHtmlEntities(s);\n}\n\nfunction decodeHtmlEntities(str) {\n  if (!str) return '';\n  const map = {\n    '&amp;':'&',\n    '&lt;':'<',\n    '&gt;':'>',\n    '&quot;':'\"',\n    '&#39;':\"'\",\n    '&nbsp;':' ',\n    '&apos;':\"'\"\n  };\n  return String(str)\n    .replace(/&(?:amp|lt|gt|quot|#39|apos|nbsp);/g, m => map[m] || m)\n    .replace(/&#(\\d+);/g, (_, n) => String.fromCharCode(parseInt(n,10)))\n    .replace(/&#x([0-9a-fA-F]+);/g, (_, h) => String.fromCharCode(parseInt(h,16)));\n}\n\nfunction removeMarkdownLinks(text) {\n  if (!text) return '';\n  // Poista <URL> -syntaksi (Markdown/Outlook angle brackets)\n  return text.replace(/<(https?:\\/\\/[^>]+)>/gi, '$1');\n}\n\nfunction decodeSafeLinks(url) {\n  if (typeof url !== 'string') return url;\n  if (!/safelinks\\.protection\\.outlook\\.com/i.test(url)) return url;\n  try {\n    const u = new URL(url);\n    const orig = u.searchParams.get('url') || u.searchParams.get('target');\n    return orig ? decodeURIComponent(orig) : url;\n  } catch { \n    return url; \n  }\n}\n\nfunction replaceSafeLinksInText(text) {\n  if (!text) return '';\n  return text.replace(/\\bhttps?:\\/\\/[^\\s)>\\]]+/gi, m => decodeSafeLinks(m));\n}\n\nfunction normalizeWhitespace(s) {\n  if (!s) return '';\n  let t = s\n    .replace(/\\r\\n/g,'\\n')           // Windows → Unix line endings\n    .replace(/\\t/g,' ')              // Tabs → spaces\n    .replace(/[ \\u00A0]+/g,' ')      // Multiple spaces + non-breaking → single space\n    .replace(/ *\\n */g,'\\n')         // Remove spaces around newlines\n    .replace(/\\u034F|\\u200B|\\u200C|\\u200D|\\u2060|\\uFEFF/g,''); // Zero-width chars\n  \n  t = t.replace(/\\n{3,}/g,'\\n\\n');   // Max 2 consecutive newlines\n  \n  // Poista ylimääräiset rivit alusta/lopusta (jos konfiguroitu)\n  if (TRIM_LINES > 0) {\n    const lines = t.split('\\n');\n    t = lines.slice(TRIM_LINES, Math.max(lines.length - TRIM_LINES, 0)).join('\\n');\n  }\n  \n  return t.trim();\n}\n\nfunction smartTruncate(s, limit) {\n  if (typeof s !== 'string') return { text: '', truncated: false };\n  if (s.length <= limit) return { text: s, truncated: false };\n  \n  // Yritä katkaista kappaleen rajalta (optimaalisin)\n  const par = s.lastIndexOf('\\n\\n', limit);\n  if (par > limit * 0.6) {\n    return { text: s.slice(0, par).trim(), truncated: true };\n  }\n  \n  // Toiseksi yritä lauseen lopusta\n  const dot = s.lastIndexOf('. ', limit);\n  if (dot > limit * 0.6) {\n    return { text: s.slice(0, dot + 1).trim(), truncated: true };\n  }\n  \n  // Viimeisenä keinona katkaise suoraan\n  return { text: s.slice(0, limit).trim(), truncated: true };\n}\n\nconst sha256 = s => crypto.createHash('sha256').update(s || '', 'utf8').digest('hex');\nconst estimateTokens = s => (s ? Math.ceil(String(s).length / 4) : 0);\n\nfunction pickRaw(i) {\n  const plain =\n    i.body_text ??\n    (i.body && i.body.contentType === 'text' ? i.body.content : null) ??\n    i.textBody ?? null;\n\n  const html =\n    i.body_html ??\n    (i.body && i.body.contentType === 'html' ? i.body.content : null) ??\n    (typeof i.content === 'string' ? i.content : null) ??\n    i.htmlBody ?? null;\n\n  return { plain, html };\n}\n\nfunction omit(o, keys) {\n  const out = {};\n  for (const k of Object.keys(o || {})) {\n    if (!keys.includes(k)) out[k] = o[k];\n  }\n  return out;\n}\n\n// ============================================================\n// PÄÄAJO\n// ============================================================\n\nreturn items.map(item => {\n  const i = item.json || {};\n\n  // Auditoi raakasisältö (tallenna metadata, älä välitä eteenpäin)\n  const rawContent = typeof i.content === 'string' ? i.content : null;\n  const content_len = rawContent ? rawContent.length : 0;\n  const content_hash = rawContent ? sha256(rawContent) : null;\n\n  let baseText = '';\n  let bodySource = 'none';\n  \n  // PRIORISOI: body_content (kannasta) > pickRaw (API-data)\n  if (typeof i.body_content === 'string' && i.body_content.length > 0) {\n    baseText = stripHtml(String(i.body_content));\n    bodySource = 'db';\n  } else {\n    const { plain, html } = pickRaw(i);\n    baseText = (plain && String(plain).trim().length > 0)\n      ? String(plain)\n      : stripHtml(String(html || ''));\n    bodySource = plain ? 'text' : (html ? 'html→text' : 'none');\n  }\n\n  // PROSESSOINTI: Markdown → SafeLinks → Whitespace → Truncate\n  const cleanedMarkdown = removeMarkdownLinks(baseText);\n  const withUrls = replaceSafeLinksInText(cleanedMarkdown);\n  const normalized = normalizeWhitespace(withUrls);\n  const { text: body_text, truncated } = smartTruncate(normalized, MAX_BODY_CHARS);\n\n  const body_hash = sha256(body_text);\n  const tokens_est = estimateTokens(body_text);\n\n  // KRIITTINEN KORJAUS: Poista sekä 'content' ETTÄ 'body_content'\n  // Näin vanha HTML-sisältö ei kopioidu läpi\n  const passthrough = omit(i, ['content', 'body_content']);\n\n  return {\n    json: {\n      ...passthrough,\n      // Metadata raakasisällöstä (audit trail)\n      content_len,\n      content_hash,\n      // Puhdistettu sisältö AI:lle\n      body_text,           // ← TÄMÄ on puhdistettu versio\n      body_hash,\n      tokens_est,\n      body_truncated: truncated,\n      body_source: bodySource,\n      body_chars: body_text.length,\n      max_body_chars: MAX_BODY_CHARS,\n    },\n  };\n});"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -160,
        -240
      ],
      "id": "5c7757fb-ae59-4fd3-8b87-12d421e0900d",
      "name": "pre_ai_guard"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH upd AS (\n  UPDATE outlook.emails_ingest e\n  SET auto_processed = true,\n      updated_at = NOW()\n  WHERE e.message_id = $1\n    AND COALESCE(e.is_deleted, false) = false\n    AND e.analyzed_at IS NULL\n    AND COALESCE(e.auto_processed, false) = false\n  RETURNING e.*\n)\nSELECT\n  u.message_id,\n  u.internet_message_id,\n  u.parent_folder_id AS folder_id,\n  u.subject,\n  u.from_domain,\n  u.from_address,\n  COALESCE(eb.content, u.body_preview) AS content,\n  u.received_datetime,\n  'signal'::text AS analysis_level,\n  'ai_classify_emails'::text AS model_name,\n  'v1'::text AS model_version,\n  'ca-1'::text AS analyzer_version\nFROM upd u\nLEFT JOIN outlook.email_bodies eb ON eb.message_id = u.message_id;",
        "options": {
          "queryReplacement": "={{ [ $json.message_id || 100 ] }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        32,
        -416
      ],
      "id": "8b2438d1-b189-427a-abeb-d53879842c48",
      "name": "mark_validated",
      "notesInFlow": true,
      "credentials": {
        "postgres": {
          "id": "4rl59kH75QNg0oSk",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// split_in_batches — n8n Code (JavaScript)\n// Jakaa items-arrayn N batchiin (ei N itemmiä per batch!)\n// Parittomissa ylimääräiset menevät VIIMEISEEN batchiin\n\n// LUE konfiguraatio\nconst cfg = $node['set_config']?.json || {};\nconst NUM_BATCHES = Number(cfg.batch ?? 1); // Montako batchia halutaan\nconst upn = cfg.user_upn || $json.user_upn || $env.USER_UPN || null;\n\n// Validoi että on items\nif (!items || items.length === 0) {\n  return [];\n}\n\n// Jos halutaan enemmän batcheja kuin on itemejä, tee batch per item\nconst actualBatches = Math.min(NUM_BATCHES, items.length);\n\n// Laske items per batch (pyöristetään ALAS)\nconst itemsPerBatch = Math.floor(items.length / actualBatches);\nconst remainder = items.length % actualBatches; // Ylimääräiset\n\nconst batches = [];\nlet startIndex = 0;\n\nfor (let batchNum = 1; batchNum <= actualBatches; batchNum++) {\n  // Viimeinen batch saa kaikki ylimääräiset\n  const isLastBatch = (batchNum === actualBatches);\n  const currentBatchSize = isLastBatch \n    ? itemsPerBatch + remainder \n    : itemsPerBatch;\n  \n  const slice = items.slice(startIndex, startIndex + currentBatchSize);\n  \n  batches.push({\n    json: {\n      user_upn: upn,\n      batch_items: slice.map(it => ({\n        ...it.json,\n        user_upn: upn\n      })),\n      batch_number: batchNum,\n      batch_size: slice.length,\n      total_items: items.length,\n      total_batches: actualBatches\n    }\n  });\n  \n  startIndex += currentBatchSize;\n}\n\nreturn batches;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        32,
        -240
      ],
      "id": "69e8bbde-e740-4458-8a2a-aaf88a2b2b21",
      "name": "split_in_batches"
    },
    {
      "parameters": {
        "values": {
          "number": [
            {
              "name": "batch",
              "value": 2
            },
            {
              "name": "offset"
            },
            {
              "name": "limit",
              "value": 4
            },
            {
              "name": "MAX_BODY_CHARS",
              "value": 100000
            }
          ],
          "string": [
            {
              "name": "user_upn",
              "value": "jouni.pappila@repoxcapital.fi"
            }
          ]
        },
        "options": {
          "dotNotation": false
        }
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 2,
      "position": [
        -656,
        -240
      ],
      "id": "9a185a2d-e343-4d16-bc9e-aa8c046a0ee1",
      "name": "set_config"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH picked AS (\n  SELECT\n    e.user_upn,\n    e.message_id,\n    e.internet_message_id,\n    e.parent_folder_id,\n    e.subject,\n    e.from_domain,\n    e.from_address,\n    e.body_preview,\n    e.received_datetime,\n    e.needs_body,\n    e.analyzed_at,\n    COALESCE(e.auto_processed, false) AS was_started\n  FROM outlook.emails_ingest e\n  WHERE e.analyzed_at IS NULL\n    AND COALESCE(e.is_deleted, false) = false\n    AND COALESCE(e.auto_processed, false) = false\n  ORDER BY was_started DESC, e.received_datetime DESC\n  LIMIT $1 OFFSET $2\n  FOR UPDATE SKIP LOCKED\n)\nSELECT\n  p.user_upn,\n  p.message_id,\n  p.internet_message_id,\n  p.parent_folder_id AS folder_id,\n  p.subject,\n  p.from_domain,\n  p.from_address,\n  p.body_preview,\n  eb.content                       AS body_content,\n  COALESCE(NULLIF(eb.content,''),NULL) IS NOT NULL AS has_body,\n  CASE WHEN eb.content IS NOT NULL THEN 'html' ELSE NULL END AS body_content_type,\n  COALESCE(length(eb.content),0)    AS body_size_bytes,\n  p.received_datetime,\n  p.needs_body,\n  p.analyzed_at\nFROM picked p\nLEFT JOIN outlook.email_bodies eb\n  ON eb.message_id = p.message_id;",
        "options": {
          "queryReplacement": "={{ [ \n  $json.limit || 500,    // $1\n  $json.offset || 0      // $2\n] }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        -512,
        -240
      ],
      "id": "e216e894-ce75-4459-b024-e03188ad0a63",
      "name": "candidate_select",
      "notesInFlow": true,
      "credentials": {
        "postgres": {
          "id": "4rl59kH75QNg0oSk",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "731d847a-9c7b-4f6d-a850-ad3d7056722b",
              "leftValue": "={{ $json.has_body }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            },
            {
              "id": "5a569f3f-98a7-4299-967c-9a894f9ffb48",
              "leftValue": "={{ $json.analyzed_at }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "empty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -368,
        -240
      ],
      "id": "bef1bd71-047d-43cd-ad07-833fbb7f6160",
      "name": "if_has_body"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "731d847a-9c7b-4f6d-a850-ad3d7056722b",
              "leftValue": "={{ $json.needs_body }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -816,
        -32
      ],
      "id": "b9857f4e-3db8-4efc-891d-95c9eb44790a",
      "name": "if_needs_body"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH input AS (\n  SELECT COALESCE($1::jsonb, '[]'::jsonb) AS j\n),\nids AS (\n  SELECT value::text AS message_id\n  FROM input, jsonb_array_elements_text(j)\n)\nSELECT\n  eb.message_id,\n  eb.content        AS body_content,\n  eb.content_type   AS body_content_type,\n  eb.size_bytes     AS body_size_bytes,\n  eb.created_at\nFROM outlook.email_bodies eb\nJOIN ids i ON i.message_id = eb.message_id;\n",
        "options": {
          "queryReplacement": "={{ JSON.stringify($('collect_message_ids').item.json.message_ids) }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        -336,
        64
      ],
      "id": "bcd25ef9-f54a-4543-b22e-98e454a1ca02",
      "name": "db_read_bodies",
      "notesInFlow": true,
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "4rl59kH75QNg0oSk",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Kerää KAIKKI message_id:t yhdeksi arrayksi\nconst messageIds = items\n  .map(it => it?.json?.message_id)\n  .filter(Boolean)\n  .map(String);\n\nconst userUpn = items[0]?.json?.user_upn || null;\n\n// Säilytä alkuperäiset itemit merge-vaihetta varten\nconst batchItems = items.map(it => it.json);\n\nreturn [{\n  json: {\n    user_upn: userUpn,\n    message_ids: messageIds,           // Array ID:istä\n    batch_items: batchItems,           // Alkuperäiset itemit\n    count: messageIds.length\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -656,
        64
      ],
      "id": "e4a322da-42bd-4a10-85b4-43529cb89104",
      "name": "collect_message_ids"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -160,
        -32
      ],
      "id": "1777ae9a-41c6-43af-8cda-c58252468977",
      "name": "Merge"
    },
    {
      "parameters": {
        "jsCode": "// Mode: Run Once for Each Item\n// Injektoi body_content jos puuttuu\n\nreturn items.map(item => {\n  const j = { ...(item.json || {}) };\n  \n  // Jos body_content on jo olemassa ja pitkä, ei tehdä mitään\n  if (typeof j.body_content === 'string' && j.body_content.length > 100) {\n    j.has_body = true;\n    j.needs_body = false;\n    j.body_source = j.body_source || 'db';\n    return { json: j };\n  }\n  \n  // Jos body_content puuttuu tai on null\n  j.has_body = false;\n  j.needs_body = true;\n  j.body_source = 'missing';\n  \n  return { json: j };\n});"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        -32
      ],
      "id": "30980adc-73f2-4ec9-8ee5-db0b5591dc3d",
      "name": "inject_body_content"
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": 4
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        -832,
        -240
      ],
      "id": "a6e380e8-7ce7-423f-b3f2-36ffccf4988c",
      "name": "Schedule Trigger 7 min"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "TsTxIrioevksSR3N",
          "mode": "list",
          "cachedResultUrl": "/workflow/TsTxIrioevksSR3N",
          "cachedResultName": "My project — Outlook Validate Analyse"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [
            "needs_ai"
          ],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "mode": "each",
        "options": {
          "waitForSubWorkflow": false
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        240,
        -240
      ],
      "name": "Call Outlook Validate Analyse",
      "id": "e4b95f1d-3db5-4349-b262-79c90db70475",
      "notesInFlow": true
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "6Qomu65xisHCsdCY",
          "mode": "list",
          "cachedResultUrl": "/workflow/6Qomu65xisHCsdCY",
          "cachedResultName": "My project — Outlook Body Fetch"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        -496,
        64
      ],
      "id": "48d7aaa4-604b-4133-b92b-7eb5a0f3d8e1",
      "name": "Call body Fetch",
      "notesInFlow": true
    }
  ],
  "connections": {
    "pre_ai_guard": {
      "main": [
        [
          {
            "node": "split_in_batches",
            "type": "main",
            "index": 0
          },
          {
            "node": "mark_validated",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "mark_validated": {
      "main": [
        []
      ]
    },
    "split_in_batches": {
      "main": [
        [
          {
            "node": "Call Outlook Validate Analyse",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "set_config": {
      "main": [
        [
          {
            "node": "candidate_select",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "candidate_select": {
      "main": [
        [
          {
            "node": "if_has_body",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "if_has_body": {
      "main": [
        [
          {
            "node": "pre_ai_guard",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "if_needs_body",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "if_needs_body": {
      "main": [
        [
          {
            "node": "collect_message_ids",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "db_read_bodies": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "collect_message_ids": {
      "main": [
        [
          {
            "node": "Call body Fetch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "inject_body_content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "inject_body_content": {
      "main": [
        [
          {
            "node": "pre_ai_guard",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schedule Trigger 7 min": {
      "main": [
        [
          {
            "node": "set_config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call body Fetch": {
      "main": [
        [
          {
            "node": "db_read_bodies",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {
    "Schedule Trigger 7 min": [
      {
        "timestamp": "2025-10-08T14:52:02.003+03:00",
        "Readable date": "October 8th 2025, 2:52:02 pm",
        "Readable time": "2:52:02 pm",
        "Day of week": "Wednesday",
        "Year": "2025",
        "Month": "October",
        "Day of month": "08",
        "Hour": "14",
        "Minute": "52",
        "Second": "02",
        "Timezone": "Europe/Helsinki (UTC+03:00)"
      }
    ]
  },
  "meta": {
    "instanceId": "5bc588890427261aec904f1de6ea2c47f92f0021d7680fbf9bd2043a6f4924b2"
  }
}